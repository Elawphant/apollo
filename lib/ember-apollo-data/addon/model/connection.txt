import { Node } from 'ember-apollo-data/model';
import { Edge, type TRelayEdgeData } from './edge';
import type TirService from 'ember-apollo-data/services/ead-store';
import { tracked } from 'tracked-built-ins';
import { identifyConnection, type QueryFieldDeclaration, type RootQueryDescription } from 'ember-apollo-data/-private/util';
import { Queryable } from './queryable';
import type { TRelayPageInfo } from './page-info';
import { getOwner, setOwner } from '@ember/owner';
import type { VariableDeclaration } from 'ember-apollo-data/configurators/graph-author/variables';
import type { NodeRegistry } from './registry';
import { assert } from '@ember/debug';


export interface TRelayConnectionData {
  edges: TRelayEdgeData[],
  pageInfo: TRelayPageInfo,
  [key: string]: any,
}

export class Connection extends Queryable {
  declare store: TirService;

  declare readonly parentNode?: Node;
  declare readonly fieldNameOnParent?: string;

  declare modelName: string;

  /** 
   * `queryParams` holds the variables for the connection, even if it is a relation
   * This structure is essential and is managed only via store.
   * 
   */
  declare queryParams: Record<string, any>;

  @tracked connectionInfo: any;

  get NodeType() {
    return this.store.modelFor(this.modelName);
  }

  @tracked
  private __addedNodes: Node[] = [];
  @tracked
  private __removedNodes: Node[] = [];

  @tracked
  declare pageInfo: TRelayPageInfo;

  @tracked
  private __internalReferences: Map<string, Edge> = new Map();

  constructor(
    store: TirService,
    modelName: string,
    queryParams: VariableDeclaration = {},
    parentNode?: Node,
    fieldNameOnParent?: string,
  ) {
    super();
    const owner = getOwner(store)!
    setOwner(this, owner);
    this.store = owner.lookup(`service:${store.NAME}`) as TirService;
    this.modelName = modelName;
    this.queryParams = queryParams;
    this.parentNode = parentNode;
    this.fieldNameOnParent = fieldNameOnParent;
  }

  /**
   * Adds Nodes to the connection without persisting to the database
   * This method should be called for managing local state of the connection
   */
  public addNodes = (...nodes: Node[]) => {
    nodes.forEach((node) => {
      if (this.__removedNodes.includes(node)) {
        this.__removedNodes.splice(this.__removedNodes.indexOf(node), 1);
      }
    });
    this.__addedNodes.push(...nodes);
  };

  public removeNodes = (...nodes: Node[]) => {
    nodes.forEach((node) => {
      if (this.__addedNodes.includes(node)) {
        this.__addedNodes.splice(this.__addedNodes.indexOf(node), 1);
      }
      if (!this.__removedNodes.includes(node)){
        this.__removedNodes.push(node);
      }
    });
  };


  get CLIENT_ID(): string {
    return identifyConnection({
      modelName: this.modelName,
      queryParams: this.queryParams,
      parentNodeId: this.parentNode?.id,
      fieldNameOnParent: this.fieldNameOnParent,
    });
  }

  get edges(): Edge[] {
    return Array.from(this.__internalReferences).map(([node, edge]) => {
      return edge;
    });
  }

  get nodes(): Node[] {
    const nodes = [
      ...Array.from(this.__internalReferences).map(([node, edge]) => this.store.internalStore.getNodeByClientId(node)!),
      ...this.__addedNodes,
    ].filter((node) => !this.__removedNodes.includes(node));
    return nodes;
  }

  public encapsulate = (data: TRelayConnectionData): void => {
    const {edges, ...rest} = data;
    function checkAlias(key: string) {
      const regex = /Node_\d+$/;
      return regex.test(key);
    
    }
    this.connectionInfo = rest;
    edges.forEach(edgeData => {
      const node = Object.entries(edgeData).reduce((prev, current) => {
        const [key, value] = current;
        return checkAlias(key) ? current : prev;
      })[1];
      const edge = new Edge(edgeData);
      const NodeInstance = this.store.node(this.modelName, node);
      this.__internalReferences.set(NodeInstance.CLIENT_ID, edge);
    });
    this.setLoadedOnce();
  }


  protected get queryConfig(): { [modelName: keyof NodeRegistry]: RootQueryDescription } {
    if (this.parentNode){
      assert(`Cannot query a Node without id.`, this.parentNode.id);
      return {
        [(this.parentNode.constructor as typeof Node).modelName]: {
          type: "node",
          fields: [this.fieldNameOnParent] as QueryFieldDeclaration[],
          variables: {
            id: this.parentNode.id,
            ...this.queryParams
          },
        }
      }
    } else {
      return {
        [(this.constructor as typeof Node).modelName]: {
          type: "connection",
          variables: this.queryParams
        }
      }
    }
  }


}
